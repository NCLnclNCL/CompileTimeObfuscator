using System;
using System.Buffers;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CompileTimeObfuscator;

internal enum ObfuscationType
{
    None, // when error
    String,
    IMemoryOwnerChar,
    ByteArray,
    IMemoryOwnerByte,
}

[Generator(LanguageNames.CSharp)]   // TODO: Code maid is bad now...
public partial class ObfuscatedContentGenerator : IIncrementalGenerator
{
    internal const string NameSpaceName = "CompileTimeObfuscator";
    internal const string ObfuscatedStringAttributionClassName = "ObfuscatedStringAttribute";
    internal const string FullyQualifiedObfuscatedStringAttributeClassName = $"{NameSpaceName}.{ObfuscatedStringAttributionClassName}";
    internal const string ObfuscatedBytesAttributionClassName = "ObfuscatedBytesAttribute";
    internal const string FullyQualifiedObfuscatedBytesAttributeClassName = $"{NameSpaceName}.{ObfuscatedBytesAttributionClassName}";
    internal const string ClearableBufferClassName = "ClearableBuffer";
    internal const string FullyQualifiedClearableBufferClassName = $"{NameSpaceName}.{ClearableBufferClassName}";

    public void Initialize(IncrementalGeneratorInitializationContext initializationContext)
    {
        initializationContext.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("CompileTimeObfuscator.g.cs", $$"""
                // <auto-generated/>
                #nullable disable

                using System;
                using System.Buffers;
                using System.Diagnostics;

                namespace {{NameSpaceName}};

                /// <summary>Indicates to source generator that a target string must be obfuscated.</summary>
                [Conditional("COMPILE_TIME_ONLY")]
                [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
                internal sealed class {{ObfuscatedStringAttributionClassName}}: Attribute
                {
                    internal {{ObfuscatedStringAttributionClassName}}(string content)
                    {
                    }
                }
                
                /// <summary>Indicates to source generator that a target bytes must be obfuscated.</summary>
                [Conditional("COMPILE_TIME_ONLY")]
                [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
                internal sealed class {{ObfuscatedBytesAttributionClassName}}: Attribute
                {
                    internal {{ObfuscatedBytesAttributionClassName}}(byte[] content)
                    {
                    }
                }

                /// <summary>
                /// <para>
                /// A buffer class implementing <see cref="IMemoryOwner{T}"/>. When it is called <see cref="Dispose"/> then clears internal buffer.
                /// </para>
                /// <para>
                /// <see cref="Memory"/> property returns <see cref="Memory{T}"/> that length is originally required length.
                /// This behavior is different from an <see cref="IMemoryOwner{T}"/> returned from <see cref="MemoryPool{T}.Shared"/>.
                /// </para>
                /// </summary>
                internal sealed class ClearableBuffer<T> : IMemoryOwner<T>
                {
                    private T[] _array;
                    private readonly int _length;

                    internal ClearableBuffer(int length)
                    {
                        _array = ArrayPool<T>.Shared.Rent(length);
                        _length = length;
                    }

                    public void Dispose()
                    {
                        if (_array is null) { return; }

                        ArrayPool<T>.Shared.Return(_array, clearArray: true);
                        _array = null;
                    }

                    public Memory<T> Memory
                    {
                        get
                        {
                            if (_array is null)
                            {
                                throw new ObjectDisposedException(GetType().FullName);
                            }
                            return new Memory<T>(_array, 0, _length);
                        }
                    }
                }
                """);
        });


        void RegisterAttributeAndEmitAction(
            string fullyQualifiedAttributeName,
            Action<SourceProductionContext, GeneratorAttributeSyntaxContext> emitter)
        {
            var source = initializationContext.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedAttributeName,
                static (syntaxNode, cancellationToken) => true,
                static (syntaxContext, cancellationToken) => syntaxContext);
            initializationContext.RegisterSourceOutput(source, emitter);
        }
        RegisterAttributeAndEmitAction(FullyQualifiedObfuscatedStringAttributeClassName, EmitCodeForObfuscatedString);
        RegisterAttributeAndEmitAction(FullyQualifiedObfuscatedBytesAttributeClassName, EmitCodeForObfuscatedBytes);

    }

    private static void EmitCodeForObfuscatedString(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        EmitCodeCore(
            context,
            source,
            FullyQualifiedObfuscatedStringAttributeClassName,
            ImmutableArray.Create(ObfuscationType.String, ObfuscationType.IMemoryOwnerChar),
            DiagnosticDescriptors.InvalidReturnTypeForObfuscatedString);
    }
    private static void EmitCodeForObfuscatedBytes(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        EmitCodeCore(
            context,
            source,
            FullyQualifiedObfuscatedBytesAttributeClassName,
            ImmutableArray.Create(ObfuscationType.ByteArray, ObfuscationType.IMemoryOwnerByte),
            DiagnosticDescriptors.InvalidReturnTypeForObfuscatedBytes);
    }

    private static void EmitCodeCore(SourceProductionContext context, GeneratorAttributeSyntaxContext source, string fullyQualifiedAttributeName, ImmutableArray<ObfuscationType> validReturnTypes, DiagnosticDescriptor diagnosticDescriptorWhenInvalidReturnType)
    {
        var methodSymbol = (IMethodSymbol)source.TargetSymbol;
        var methodDeclarationSyntax = (MethodDeclarationSyntax)source.TargetNode;

        var obfuscationType = GetObfuscationTypeWithDiagnostics(
            context,
            methodSymbol,
            methodDeclarationSyntax,
            source.SemanticModel,
            validReturnTypes,
            diagnosticDescriptorWhenInvalidReturnType);
        if (obfuscationType == ObfuscationType.None)
        {
            return;
        }

        var containingClassSymbol = methodSymbol.ContainingType;
        if (containingClassSymbol == null)
        {
            return; // when the method is not contained with in type. I'm not sure this will happen when using C# language.
        }

        // If I use "Span<byte> key = stackalloc byte[16];" then
        // I get a error "The target process exited with code -2146233082 (0x80131506) while evaluating the function '<LAST_USED_METHOD>'."
        // I don't know why, but I can avoid that by using MemoryPool.
        int keySize = 16;
        using var keyBuffer = MemoryPool<byte>.Shared.Rent(16);
        var keySpan = keyBuffer.Memory.Span.Slice(0, keySize);

        IMemoryOwner<byte> encryptedBuffer;
        int encryptedElementCount;
        if (fullyQualifiedAttributeName == FullyQualifiedObfuscatedStringAttributeClassName)
        {
            var typedConstant = GetAttributeConstructorArgumentToObfuscateWithDiagnostics(methodSymbol, fullyQualifiedAttributeName);
            string str = (string)typedConstant.Value!;
            encryptedBuffer = MemoryPool<byte>.Shared.Rent(str.Length * 2);
            encryptedElementCount = XorEncryptor.GenerateKeyAndEncryptContent(str.AsSpan(), keySpan, encryptedBuffer.Memory.Span);// TODO: needs asspan?
        }
        else if (fullyQualifiedAttributeName == FullyQualifiedObfuscatedBytesAttributeClassName)
        {
            var typedConstant = GetAttributeConstructorArgumentToObfuscateWithDiagnostics(methodSymbol, fullyQualifiedAttributeName);
            byte[] bytes = typedConstant.Values.Select(x => (byte)x.Value!).ToArray();
            encryptedBuffer = MemoryPool<byte>.Shared.Rent(bytes.Length);
            encryptedElementCount = XorEncryptor.GenerateKeyAndEncryptContent(bytes, keySpan, encryptedBuffer.Memory.Span);
        }
        else
        {
            throw new InvalidOperationException($"Unknown fullyQualifiedAttributeName: {fullyQualifiedAttributeName}");
        }

        var encryptedSpan = encryptedBuffer.Memory.Span.Slice(0, encryptedElementCount);

        using (encryptedBuffer)
        {
            string decryptionCode = obfuscationType switch
            {
                ObfuscationType.String => XorEncryptor.GenerateDecryptionCodeForString(encryptedSpan, keySpan, true),
                ObfuscationType.IMemoryOwnerChar => XorEncryptor.GenerateDecryptionCodeForString(encryptedSpan, keySpan, false),
                ObfuscationType.ByteArray => XorEncryptor.GenerateDecryptionCodeForBytes(encryptedSpan, keySpan, true),
                ObfuscationType.IMemoryOwnerByte => XorEncryptor.GenerateDecryptionCodeForBytes(encryptedSpan, keySpan, false),
                _ => throw new InvalidOperationException(),
            };

            string methodReturnType = methodSymbol.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            string code = $$"""
            // <auto-generated/>
            {{(methodSymbol.ContainingNamespace.IsGlobalNamespace ? string.Empty : $"{Environment.NewLine}namespace {methodSymbol.ContainingNamespace};")}}
            partial class {{methodSymbol.ContainingType.Name}}
            {
                {{SyntaxFacts.GetText(methodSymbol.DeclaredAccessibility)}}{{(methodSymbol.IsStatic ? " static" : string.Empty)}} partial {{methodReturnType}} {{methodSymbol.Name}}()
                {
            {{decryptionCode}}
                }
            }

            """;

            string generatingSourceFileName = Utils.SanitizeForFileName($"{(containingClassSymbol == null ? "__global__" : string.Empty)}.{methodSymbol.Name}.{methodReturnType}.CompileTimeObfuscator.g.cs");

            context.AddSource(generatingSourceFileName, code);
        }
    }

    /// <summary>Returns value if there is no syntax error. Returns <see cref="ObfuscationType.None"/> and report diagnostic otherwise.</summary>
    private static ObfuscationType GetObfuscationTypeWithDiagnostics(
        SourceProductionContext context,
        IMethodSymbol methodSymbol,
        MethodDeclarationSyntax methodDeclarationSyntax,
        SemanticModel semanticModel,
        ImmutableArray<ObfuscationType> validReturnTypes,
        DiagnosticDescriptor diagnosticDescriptorWhenInvalidReturnType)
    {
        var typeIMemoryOwnderOpened = semanticModel.Compilation.GetTypeByMetadataName("System.Buffers.IMemoryOwner`1")!;
        var typeByte = semanticModel.Compilation.GetTypeByMetadataName("System.Byte")!;
        var typeChar = semanticModel.Compilation.GetTypeByMetadataName("System.Char")!;
        var typeString = semanticModel.Compilation.GetTypeByMetadataName("System.String")!;
        var typeIMemoryOwnderByte = typeIMemoryOwnderOpened.Construct(typeByte);
        var typeIMemoryOwnderChar = typeIMemoryOwnderOpened.Construct(typeChar);
        var typeByteArray = semanticModel.Compilation.CreateArrayTypeSymbol(typeByte);

        bool HasReturnType(ISymbol symbol) => SymbolEqualityComparer.Default.Equals(methodSymbol.ReturnType, symbol);

        var obfuscationType = HasReturnType(typeString) ? ObfuscationType.String :
            HasReturnType(typeIMemoryOwnderChar) ? ObfuscationType.IMemoryOwnerChar :
            HasReturnType(typeByteArray) ? ObfuscationType.ByteArray :
            HasReturnType(typeIMemoryOwnderByte) ? ObfuscationType.IMemoryOwnerByte :
            ObfuscationType.None;

        if (!validReturnTypes.Contains(obfuscationType))
        {
            context.ReportDiagnostic(Diagnostic.Create(diagnosticDescriptorWhenInvalidReturnType, methodDeclarationSyntax.Identifier.GetLocation()));
            return ObfuscationType.None;
        }

        if (methodSymbol.Parameters.Length > 0)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MethodMustNotHaveParameters, methodDeclarationSyntax.Identifier.GetLocation()));
            return ObfuscationType.None;
        }

        if (methodSymbol.Arity > 0)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MethodMustNotHaveTypeParameters, methodDeclarationSyntax.Identifier.GetLocation()));
            return ObfuscationType.None;
        }

        if (!methodSymbol.IsPartialDefinition)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MethodMustBePartial, methodDeclarationSyntax.Identifier.GetLocation()));
            return ObfuscationType.None;
        }

        return obfuscationType;
    }

    /// <summary>Returns attribute constructor's argument.</summary>
    private static TypedConstant GetAttributeConstructorArgumentToObfuscateWithDiagnostics(IMethodSymbol methodSymbol, string fullyQualifiedAttributeName)
    {
        var attributeData = methodSymbol.GetAttributes().Single(
            x => x.AttributeClass?.ToDisplayString() == fullyQualifiedAttributeName);

        if (attributeData.ConstructorArguments.Length != 1)
        {
            throw new InvalidOperationException($"ConstructorArguments.Length is {attributeData.ConstructorArguments.Length}");
        }

        return attributeData.ConstructorArguments[0];
    }
}

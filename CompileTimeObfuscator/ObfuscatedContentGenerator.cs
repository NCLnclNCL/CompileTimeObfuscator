using System;
using System.Buffers;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CompileTimeObfuscator;

internal enum ObfuscationType
{
    None, // when error
    String,
    IMemoryOwnerByte,
}

[Generator(LanguageNames.CSharp)]   // TODO: Code maid is bad now...
public partial class ObfuscatedContentGenerator : IIncrementalGenerator
{
    internal const string NameSpaceName = "CompileTimeObfuscator";
    internal const string ObfuscatedStringAttributionClassName = "ObfuscatedStringAttribute";
    internal const string FullyQualifiedObfuscatedStringAttributeClassName = $"{NameSpaceName}.{ObfuscatedStringAttributionClassName}";
    internal const string ObfuscatedBytesAttributionClassName = "ObfuscatedBytesAttribute";
    internal const string FullyQualifiedObfuscatedBytesAttributeClassName = $"{NameSpaceName}.{ObfuscatedBytesAttributionClassName}";
    internal const string ClearableBufferClassName = "ClearableBuffer";
    internal const string FullyQualifiedClearableBufferClassName =$"{NameSpaceName}.{ClearableBufferClassName}";

    public void Initialize(IncrementalGeneratorInitializationContext initializationContext)
    {
        initializationContext.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("CompileTimeObfuscator.g.cs", $$"""
                // <auto-generated/>
                #nullable disable

                using System;
                using System.Buffers;
                using System.Diagnostics;

                namespace {{NameSpaceName}};

                /// <summary>Indicates to source generator that a target string must be obfuscated.</summary>
                [Conditional("COMPILE_TIME_ONLY")]
                [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
                internal sealed class {{ObfuscatedStringAttributionClassName}}: Attribute
                {
                    internal {{ObfuscatedStringAttributionClassName}}(string content)
                    {
                    }
                }
                
                /// <summary>Indicates to source generator that a target bytes must be obfuscated.</summary>
                [Conditional("COMPILE_TIME_ONLY")]
                [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
                internal sealed class {{ObfuscatedBytesAttributionClassName}}: Attribute
                {
                    internal {{ObfuscatedBytesAttributionClassName}}(byte[] content)
                    {
                    }
                }

                /// <summary>
                /// <para>
                /// A buffer class implementing <see cref="IMemoryOwner{byte}"/>. When it is called <see cref="Dispose"/> then clears internal buffer.
                /// </para>
                /// <para>
                /// <see cref="Memory"/> property returns <see cref="Memory{byte}"/> that length is originally required length.
                /// This behavior is not same as an <see cref="IMemoryOwner{byte}"/> returned from <see cref="MemoryPool{T}.Shared"/>.
                /// </para>
                /// </summary>
                internal sealed class ClearableBuffer : IMemoryOwner<byte>
                {
                    private byte[] _array;
                    private readonly int _length;

                    internal ClearableBuffer(int length)
                    {
                        _array = ArrayPool<byte>.Shared.Rent(length);
                        _length = length;
                    }

                    public void Dispose()
                    {
                        if (_array is null) { return; }

                        ArrayPool<byte>.Shared.Return(_array, clearArray: true);
                        _array = null;
                    }

                    public Memory<byte> Memory
                    {
                        get
                        {
                            if (_array is null)
                            {
                                throw new ObjectDisposedException(GetType().FullName);
                            }
                            return new ArraySegment<byte>(_array, 0, _length);
                        }
                    }
                }
                """);
        });


        void RegisterAttributeAndEmitAction(
            string fullyQualifiedAttributeName,
            Action<SourceProductionContext, GeneratorAttributeSyntaxContext> emitter)
        {
            var source = initializationContext.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedAttributeName,
                static (syntaxNode, cancellationToken) => true,
                static (syntaxContext, cancellationToken) => syntaxContext);
            initializationContext.RegisterSourceOutput(source, emitter);
        }
        RegisterAttributeAndEmitAction(FullyQualifiedObfuscatedStringAttributeClassName, EmitCodeForObuscatedString);
        RegisterAttributeAndEmitAction(FullyQualifiedObfuscatedBytesAttributeClassName, EmitCodeForObuscatedBytes);

    }

    private static void EmitCodeForObuscatedString(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        EmitCodeCore(context, source, FullyQualifiedObfuscatedStringAttributeClassName, true);
    }
    private static void EmitCodeForObuscatedBytes(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        EmitCodeCore(context, source, FullyQualifiedObfuscatedBytesAttributeClassName, false);
    }

    private static void EmitCodeCore(SourceProductionContext context, GeneratorAttributeSyntaxContext source, string fullyQualifiedAttributeName, bool convertToString)
    {
        var methodSymbol = (IMethodSymbol)source.TargetSymbol;
        var methodDeclarationSyntax = (MethodDeclarationSyntax)source.TargetNode;

        var obfuscationType = GetObfuscationTypeWithDiagnostics(context, methodSymbol, methodDeclarationSyntax, source.SemanticModel);
        if (obfuscationType == ObfuscationType.None)
        {
            return;
        }

        var containingClassSymbol = methodSymbol.ContainingType;
        if (containingClassSymbol == null)
        {
            return; // when the method is not contained with in type. I'm not sure this will happen when using C# language.
        }

        // var (encryptedContent, key, iv) = AesEncryptor.EncryptContent(contentToObfuscate);
        // If I use "Span<byte> key = stackalloc byte[16];" then
        // I get a error "The target process exited with code -2146233082 (0x80131506) while evaluating the function '<LAST_USED_METHOD>'."
        // I don't know why, but I can avoid that by using MemoryPool.
        using var key = MemoryPool<byte>.Shared.Rent(16);
        byte[] content;
        if (convertToString)
        {
            var typedConstant = GetAttributeConstructorArgumentToObfuscateWithDiagnostics(methodSymbol, fullyQualifiedAttributeName);
            content = Encoding.UTF8.GetBytes((string)typedConstant.Value!);
        }
        else
        {
            var typedConstant = GetAttributeConstructorArgumentToObfuscateWithDiagnostics(methodSymbol, fullyQualifiedAttributeName);
            content = typedConstant.Values.Select(x => (byte)x.Value!).ToArray();
        }
        XorEncryptor.GenerateKeyAndEncryptContent(content, key.Memory.Span);

        string methodName = methodSymbol.ToDisplayString();

        string code = $$"""
        // <auto-generated/>
        {{(methodSymbol.ContainingNamespace.IsGlobalNamespace ? string.Empty : $"{Environment.NewLine}namespace {methodSymbol.ContainingNamespace};")}}
        partial class {{methodSymbol.ContainingType.Name}}
        {
            {{SyntaxFacts.GetText(methodSymbol.DeclaredAccessibility)}}{{(methodSymbol.IsStatic ? " static" : string.Empty)}} partial {{methodSymbol.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}} {{methodSymbol.Name}}()
            {
        {{XorEncryptor.GenerateDecryptionCode(content, key.Memory.Span, convertToString)}}
            }
        }

        """;

        string generatingSourceFileName = Utils.SanitizeStringForFileName($"{(containingClassSymbol == null ? $"global_{methodName}" : $"{containingClassSymbol}.{methodName}")}.ObfuscatedStringGenerator.g.cs");

        context.AddSource(generatingSourceFileName, code);
    }

    /// <summary>Returns true if there is no syntax error. Returns false and report diagnostic otherwise</summary>
    private static ObfuscationType GetObfuscationTypeWithDiagnostics(
        SourceProductionContext context,
        IMethodSymbol methodSymbol,
        MethodDeclarationSyntax methodDeclarationSyntax,
        SemanticModel semanticModel)
    {
        var typeIMemoryOwnderOpened = semanticModel.Compilation.GetTypeByMetadataName("System.Buffers.IMemoryOwner`1")!;
        var typeByte = semanticModel.Compilation.GetTypeByMetadataName("System.Byte")!;
        var typeString = semanticModel.Compilation.GetTypeByMetadataName("System.String")!;
        var typeIMemoryOwnderByte = typeIMemoryOwnderOpened.Construct(typeByte);

        ObfuscationType obfuscationType;
        if (SymbolEqualityComparer.Default.Equals(methodSymbol.ReturnType, typeString))
        {
            obfuscationType = ObfuscationType.String;
        }
        else if (SymbolEqualityComparer.Default.Equals(methodSymbol.ReturnType, typeIMemoryOwnderByte))
        {
            obfuscationType = ObfuscationType.IMemoryOwnerByte;
        }
        else
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MethodReturnTypeMustBeStringOrIMemoryOwnerByte, methodDeclarationSyntax.Identifier.GetLocation()));
            return ObfuscationType.None;
        }

        if (methodSymbol.Parameters.Length > 0)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MethodMustNotHaveParameters, methodDeclarationSyntax.Identifier.GetLocation()));
            return ObfuscationType.None;
        }

        if (methodSymbol.Arity > 0)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MethodMustNotHaveTypeParameters, methodDeclarationSyntax.Identifier.GetLocation()));
            return ObfuscationType.None;
        }

        if (!methodSymbol.IsPartialDefinition)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MethodMustBePartial, methodDeclarationSyntax.Identifier.GetLocation()));
            return ObfuscationType.None;
        }

        return obfuscationType;
    }

    /// <summary>Returns attribute constructor's argument.</summary>
    private static TypedConstant GetAttributeConstructorArgumentToObfuscateWithDiagnostics(IMethodSymbol methodSymbol, string fullyQualifiedAttributeName)
    {
        var attributeData = methodSymbol.GetAttributes().Single(
            x => x.AttributeClass?.ToDisplayString() == fullyQualifiedAttributeName);

        if (attributeData.ConstructorArguments.Length != 1)
        {
            throw new InvalidOperationException($"ConstructorArguments.Length is {attributeData.ConstructorArguments.Length}");
        }

        return attributeData.ConstructorArguments[0];
    }
}

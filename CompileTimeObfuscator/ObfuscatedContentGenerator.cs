using System;
using System.Buffers;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CompileTimeObfuscator;

internal enum ObfuscationType
{
    String,
    IMemoryOwnerChar,
    ByteArray,
    IMemoryOwnerByte,
}

[Generator(LanguageNames.CSharp)]
public partial class ObfuscatedContentGenerator : IIncrementalGenerator
{
    internal const string NameSpaceName = "CompileTimeObfuscator";
    internal const string ClassNameObfuscatedStringAttribution = "ObfuscatedStringAttribute";
    internal const string FullyQualifiedClassNameObfuscatedStringAttribute = $"{NameSpaceName}.{ClassNameObfuscatedStringAttribution}";
    internal const string ClassNameObfuscatedBytesAttribution = "ObfuscatedBytesAttribute";
    internal const string FullyQualifiedClassNameObfuscatedBytesAttribute = $"{NameSpaceName}.{ClassNameObfuscatedBytesAttribution}";
    internal const string ClassNameClearableBuffer = "ClearableBuffer";
    internal const string FullyQualifiedClassNameClearableBuffer = $"{NameSpaceName}.{ClassNameClearableBuffer}";

    internal const string PropertyNameKeyLength = "KeyLength";
    internal const string DefaultValueKeyLength = "16";
    internal const string PropertyNameClearBufferWhenDisposing = "ClearBufferWhenDisposing";
    internal const string DefaultValueClearBufferWhenDisposing = "true";

    private const string CodeForPostInitializationOutput = $$"""
        // <auto-generated/>
        #nullable disable

        using System;
        using System.Buffers;
        using System.Diagnostics;

        namespace {{NameSpaceName}};

        /// <summary>Obfuscate the specified string to preventing the specified string from appearing in a metadata. The obfuscated string is deobfuscated at runtime. The method must return <see cref="string"/> or <see cref="IMemoryOwner{T}"/> of type <see cref="char"/>.</summary>
        [Conditional("COMPILE_TIME_ONLY")]
        [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
        internal sealed class {{ClassNameObfuscatedStringAttribution}}: Attribute
        {
            /// <summary>Initializes a new instance of the <see cref="{{ClassNameObfuscatedStringAttribution}}"/> with the specified string.</summary>
            /// <param name="value">The string to obfuscate.</param>
            /// <param name="keyLength">A length of xor key.</param>
            /// <param name="clearBufferWhenDisposing"><see langword="true" /> to clear a deobfuscated buffer after disposing the <see cref="IMemoryOwner{T}"/> object; otherwise, <see langword="false" />.</param>
            internal {{ClassNameObfuscatedStringAttribution}}(string value)
            {
            }

            /// <summary>Indicates the key length to obfuscate. A default value is {{DefaultValueKeyLength}}.</summary>
            public int {{PropertyNameKeyLength}} = {{DefaultValueKeyLength}};

            /// <summary>Indicates whether a deobfuscated buffer will cleared after disposing an <see cref="IMemoryOwner{T}"/> object. A default value is {{DefaultValueClearBufferWhenDisposing}}.</summary>
            public bool {{PropertyNameClearBufferWhenDisposing}} = {{DefaultValueClearBufferWhenDisposing}};
        }

        /// <summary>Obfuscate the specified bytes to preventing the specified bytes from appearing in a metadata. The obfuscated bytes is deobfuscated at runtime. The method must return <see cref="byte"/>[] or <see cref="IMemoryOwner{T}"/> of type <see cref="byte"/>.</summary>
        [Conditional("COMPILE_TIME_ONLY")]
        [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
        internal sealed class {{ClassNameObfuscatedBytesAttribution}}: Attribute
        {
            /// <summary>Initializes a new instance of the <see cref="{{ClassNameObfuscatedBytesAttribution}}"/> with the specified bytes.</summary>
            /// <param name="value">The bytes to obfuscate.</param>
            /// <param name="keyLength">A length of xor key.</param>
            /// <param name="clearBufferWhenDisposing"><see langword="true" /> to clear a deobfuscated buffer after disposing the <see cref="IMemoryOwner{T}"/> object; otherwise, <see langword="false" />.</param>
            internal {{ClassNameObfuscatedBytesAttribution}}(byte[] value)
            {
            }

            /// <summary>Indicates the key length to obfuscate. A default value is {{DefaultValueKeyLength}}.</summary>
            public int {{PropertyNameKeyLength}} = {{DefaultValueKeyLength}};

            /// <summary>Indicates whether a deobfuscated buffer will cleared after disposing an <see cref="IMemoryOwner{T}"/> object. A default value is {{DefaultValueClearBufferWhenDisposing}}.</summary>
            public bool {{PropertyNameClearBufferWhenDisposing}} = {{DefaultValueClearBufferWhenDisposing}};
        }

        internal sealed class ClearableBuffer<T> : IMemoryOwner<T>
        {
            private T[] _array;
            private readonly int _length;
            private readonly bool _clearBufferWhenDisposing;

            internal ClearableBuffer(int length, bool clearBufferWhenDisposing)
            {
                _array = ArrayPool<T>.Shared.Rent(length);
                _length = length;
                _clearBufferWhenDisposing = clearBufferWhenDisposing;
            }

            public void Dispose()
            {
                if (_array is null) { return; }

                ArrayPool<T>.Shared.Return(_array, _clearBufferWhenDisposing);
                _array = null;
            }

            /// <summary>Returns <see cref="Memory{T}"/> that length is originally required length. This behavior is different from an <see cref="IMemoryOwner{T}"/> returned from <see cref="MemoryPool{T}.Shared"/>.</summary>
            public Memory<T> Memory
            {
                get
                {
                    if (_array is null)
                    {
                        throw new ObjectDisposedException(GetType().FullName);
                    }
                    return new Memory<T>(_array, 0, _length);
                }
            }
        }

        """;

    public void Initialize(IncrementalGeneratorInitializationContext initializationContext)
    {
        initializationContext.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource($"{NameSpaceName}.g.cs", CodeForPostInitializationOutput);
        });

        void RegisterAttributeAndEmitter(
            string fullyQualifiedAttributeName,
            ImmutableArray<ObfuscationType> validReturnTypes,
            DiagnosticDescriptor diagnosticDescriptor)
        {
            var source = initializationContext.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedAttributeName,
                static (syntaxNode, cancellationToken) => true,
                static (syntaxContext, cancellationToken) => syntaxContext);
            initializationContext.RegisterSourceOutput(
                source,
                (context, source) =>
                {
                    EmitCore(context,
                        source,
                        fullyQualifiedAttributeName,
                        validReturnTypes,
                        diagnosticDescriptor);
                });
        }
        RegisterAttributeAndEmitter(
            FullyQualifiedClassNameObfuscatedStringAttribute,
            ImmutableArray.Create(ObfuscationType.String, ObfuscationType.IMemoryOwnerChar),
            DiagnosticDescriptors.InvalidMethodSignatureForObfuscatedStringAttribute);
        RegisterAttributeAndEmitter(
            FullyQualifiedClassNameObfuscatedBytesAttribute,
            ImmutableArray.Create(ObfuscationType.ByteArray, ObfuscationType.IMemoryOwnerByte),
            DiagnosticDescriptors.InvalidMethodSignatureForObfuscatedBytesAttribute);
    }

    private static void EmitCore(
        SourceProductionContext context,
        GeneratorAttributeSyntaxContext source,
        string fullyQualifiedAttributeName,
        ImmutableArray<ObfuscationType> validReturnTypes,
        DiagnosticDescriptor diagnosticDescriptor)
    {
        var methodSymbol = (IMethodSymbol)source.TargetSymbol;
        var methodDeclarationSyntax = (MethodDeclarationSyntax)source.TargetNode;

        // ContainingType is null when the method is not contained with in type. I'm not sure this will happen when using C# language.
        var containingClassSymbol = methodSymbol.ContainingType ??
            throw new InvalidOperationException($"IMethodSymbol.ContainingType is null");

        var obfuscationType = GetObfuscationTypeWithDiagnostics(
            context,
            methodSymbol,
            methodDeclarationSyntax,
            source.SemanticModel,
            validReturnTypes,
            diagnosticDescriptor);
        if (obfuscationType == null)
        {
            return;
        }

        if (GetAttributeConstructorArgumentWithDiagnostics(
            context,
            methodSymbol,
            methodDeclarationSyntax,
            fullyQualifiedAttributeName) is not AttributeConstructorArgument attributeArgument)
        {
            return;
        }

        string deobfuscationCode;
        if (fullyQualifiedAttributeName == FullyQualifiedClassNameObfuscatedStringAttribute)
        {
            string str = (string)attributeArgument.TypedConstant.Value!;
            deobfuscationCode = XorObfuscator.GenerateCodeForDeobfuscateString(
                str.AsSpan(),
                attributeArgument.KeyLength,
                attributeArgument.ClearBufferWhenDisposing,
                obfuscationType == ObfuscationType.String);
        }
        else if (fullyQualifiedAttributeName == FullyQualifiedClassNameObfuscatedBytesAttribute)
        {
            byte[] bytes = attributeArgument.TypedConstant.Values.Select(x => (byte)x.Value!).ToArray();
            deobfuscationCode = XorObfuscator.GenerateCodeForDeobfuscateBytes(bytes,
                attributeArgument.KeyLength,
                attributeArgument.ClearBufferWhenDisposing,
                obfuscationType == ObfuscationType.ByteArray);
        }
        else
        {
            throw new InvalidOperationException($"Unknown fullyQualifiedAttributeName: {fullyQualifiedAttributeName}");
        }

        string generatedSourceCode = $$"""
            // <auto-generated/>
            {{(methodSymbol.ContainingNamespace.IsGlobalNamespace ? string.Empty : $"{Environment.NewLine}namespace {methodSymbol.ContainingNamespace};")}}
            partial class {{methodSymbol.ContainingType.Name}}
            {
                {{SyntaxFacts.GetText(methodSymbol.DeclaredAccessibility)}}{{(methodSymbol.IsStatic ? " static" : string.Empty)}} partial {{methodSymbol.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}} {{methodSymbol.Name}}()
                {
            {{deobfuscationCode}}
                }
            }

            """;

        string classPart = containingClassSymbol?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "__global__";
        string returnTypePart = methodSymbol.ReturnType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        string generatingSourceFileName = Utils.SanitizeForFileName($"{classPart}.{methodSymbol.Name}.{returnTypePart}.CompileTimeObfuscator.g.cs");

        context.AddSource(generatingSourceFileName, generatedSourceCode);
    }

    /// <summary>Returns a return-type of the method if there is no signature errors. Returns null and reports diagnostic otherwise.</summary>
    private static ObfuscationType? GetObfuscationTypeWithDiagnostics(
        SourceProductionContext context,
        IMethodSymbol methodSymbol,
        MethodDeclarationSyntax methodDeclarationSyntax,
        SemanticModel semanticModel,
        ImmutableArray<ObfuscationType> validReturnTypes,
        DiagnosticDescriptor diagnosticDescriptor)
    {
        INamedTypeSymbol GetTypeSymbolFromName(string fullyQualifiedmetadataName) =>
            semanticModel.Compilation.GetTypeByMetadataName(fullyQualifiedmetadataName) ??
            throw new InvalidOperationException($"{fullyQualifiedmetadataName} is not found");

        var typeIMemoryOwnderOpened = GetTypeSymbolFromName("System.Buffers.IMemoryOwner`1");
        var typeByte = GetTypeSymbolFromName("System.Byte");
        var typeChar = GetTypeSymbolFromName("System.Char");
        var typeString = GetTypeSymbolFromName("System.String");
        var typeIMemoryOwnderByte = typeIMemoryOwnderOpened.Construct(typeByte);
        var typeIMemoryOwnderChar = typeIMemoryOwnderOpened.Construct(typeChar);
        var typeByteArray = semanticModel.Compilation.CreateArrayTypeSymbol(typeByte);

        bool HasReturnType(ISymbol symbol) => SymbolEqualityComparer.Default.Equals(methodSymbol.ReturnType, symbol);

        var obfuscationType = HasReturnType(typeString) ? ObfuscationType.String :
            HasReturnType(typeIMemoryOwnderChar) ? ObfuscationType.IMemoryOwnerChar :
            HasReturnType(typeByteArray) ? ObfuscationType.ByteArray :
            HasReturnType(typeIMemoryOwnderByte) ? ObfuscationType.IMemoryOwnerByte :
            (ObfuscationType?)null;

        bool validSignature = obfuscationType is not null &&
            validReturnTypes.Contains(obfuscationType.Value) &&
            methodSymbol.Parameters.Length == 0 &&
            methodSymbol.Arity == 0 &&
            methodSymbol.IsPartialDefinition &&
            !methodSymbol.IsAbstract;
        if (!validSignature)
        {
            context.ReportDiagnostic(Diagnostic.Create(diagnosticDescriptor, methodDeclarationSyntax.Identifier.GetLocation(), methodSymbol.Name));
            return null;
        }

        return obfuscationType;
    }

    private record struct AttributeConstructorArgument(TypedConstant TypedConstant, int KeyLength, bool ClearBufferWhenDisposing);

    /// <summary>Returns constructor parameters of the attribute if successfully. Returns null and reports diagnostic otherwise.</summary>
    private static AttributeConstructorArgument? GetAttributeConstructorArgumentWithDiagnostics(
        SourceProductionContext context,
        IMethodSymbol methodSymbol,
        MethodDeclarationSyntax methodDeclarationSyntax,
        string fullyQualifiedAttributeName)
    {
        var attributeData = methodSymbol.GetAttributes().Single(
            x => x.AttributeClass?.ToDisplayString() == fullyQualifiedAttributeName);

        if (attributeData.ConstructorArguments.Length != 1)
        {
            throw new InvalidOperationException($"ConstructorArguments.Length is {attributeData.ConstructorArguments.Length}");
        }

        var typedConstantForValue = attributeData.ConstructorArguments[0];
        if (typedConstantForValue.IsNull)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(DiagnosticDescriptors.InvalidValueParameter, methodDeclarationSyntax.Identifier.GetLocation(), methodSymbol.Name));
            return null;
        }

        // AttributeData.NamedArguments contains explicitly specified fileds only so if a field is not specified then we must handle as absent value.
        static T GetNamedArgumentOrDefault<T>(ImmutableArray<KeyValuePair<string, TypedConstant>> namedArguments, string name, T defaultValue)
        {
            // ImmutbaleArray does not have Find method...
            foreach (var namedArgument in namedArguments)
            {
                if (StringComparer.Ordinal.Equals(namedArgument.Key, name))
                {
                    return (T)namedArgument.Value.Value!;
                }
            }
            return defaultValue;
        }

        var namedArguments = attributeData.NamedArguments;
        int keyLength = GetNamedArgumentOrDefault(namedArguments, PropertyNameKeyLength, int.Parse(DefaultValueKeyLength));
        bool clearBufferWhenDisposing = GetNamedArgumentOrDefault(namedArguments, PropertyNameClearBufferWhenDisposing, bool.Parse(DefaultValueClearBufferWhenDisposing));

        if(keyLength <= 0)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(DiagnosticDescriptors.InvalidKeyLengthParameter, methodDeclarationSyntax.Identifier.GetLocation(), methodSymbol.Name));
            return null;
        }

        return new AttributeConstructorArgument(
            typedConstantForValue,
            keyLength,
            clearBufferWhenDisposing);
    }
}

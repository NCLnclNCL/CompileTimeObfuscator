using System;
using System.Buffers;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CompileTimeObfuscator;

internal enum ObfuscationType
{
    None, // when error
    String,
    IMemoryOwnerChar,
    ByteArray,
    IMemoryOwnerByte,
}

[Generator(LanguageNames.CSharp)]   // TODO: Code maid is bad now...
public partial class ObfuscatedContentGenerator : IIncrementalGenerator
{
    internal const string NameSpaceName = "CompileTimeObfuscator";
    internal const string ObfuscatedStringAttributionClassName = "ObfuscatedStringAttribute";
    internal const string FullyQualifiedObfuscatedStringAttributeClassName = $"{NameSpaceName}.{ObfuscatedStringAttributionClassName}";
    internal const string ObfuscatedBytesAttributionClassName = "ObfuscatedBytesAttribute";
    internal const string FullyQualifiedObfuscatedBytesAttributeClassName = $"{NameSpaceName}.{ObfuscatedBytesAttributionClassName}";
    internal const string ClearableBufferClassName = "ClearableBuffer";
    internal const string FullyQualifiedClearableBufferClassName = $"{NameSpaceName}.{ClearableBufferClassName}";

    private const string CodeForPostInitializationOutput = $$"""
        // <auto-generated/>
        #nullable disable

        using System;
        using System.Buffers;
        using System.Diagnostics;

        namespace {{NameSpaceName}};

        /// <summary>Indicates to source generator that a target string must be obfuscated.</summary>
        [Conditional("COMPILE_TIME_ONLY")]
        [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
        internal sealed class {{ObfuscatedStringAttributionClassName}}: Attribute
        {
            internal {{ObfuscatedStringAttributionClassName}}(string content, int keySize = 16, bool clearBufferWhenDisposing = true)
            {
            }
        }
                
        /// <summary>Indicates to source generator that a target bytes must be obfuscated.</summary>
        [Conditional("COMPILE_TIME_ONLY")]
        [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
        internal sealed class {{ObfuscatedBytesAttributionClassName}}: Attribute
        {
            internal {{ObfuscatedBytesAttributionClassName}}(byte[] content, int keySize = 16, bool clearBufferWhenDisposing = true)
            {
            }
        }

        /// <summary>
        /// <para>
        /// A buffer class implementing <see cref="IMemoryOwner{T}"/>. When it is called <see cref="Dispose"/> then clears internal buffer.
        /// </para>
        /// <para>
        /// <see cref="Memory"/> property returns <see cref="Memory{T}"/> that length is originally required length.
        /// This behavior is different from an <see cref="IMemoryOwner{T}"/> returned from <see cref="MemoryPool{T}.Shared"/>.
        /// </para>
        /// </summary>
        internal sealed class ClearableBuffer<T> : IMemoryOwner<T>
        {
            private T[] _array;
            private readonly int _length;
            private readonly bool _clearBufferWhenDisposing;

            internal ClearableBuffer(int length, bool clearBufferWhenDisposing)
            {
                _array = ArrayPool<T>.Shared.Rent(length);
                _length = length;
                _clearBufferWhenDisposing = clearBufferWhenDisposing;
            }

            public void Dispose()
            {
                if (_array is null) { return; }

                ArrayPool<T>.Shared.Return(_array, _clearBufferWhenDisposing);
                _array = null;
            }

            public Memory<T> Memory
            {
                get
                {
                    if (_array is null)
                    {
                        throw new ObjectDisposedException(GetType().FullName);
                    }
                    return new Memory<T>(_array, 0, _length);
                }
            }
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext initializationContext)
    {
        initializationContext.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("CompileTimeObfuscator.g.cs", CodeForPostInitializationOutput);
        });

        void RegisterAttributeAndEmitAction(
            string fullyQualifiedAttributeName,
            Action<SourceProductionContext, GeneratorAttributeSyntaxContext> emitter)
        {
            var source = initializationContext.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedAttributeName,
                static (syntaxNode, cancellationToken) => true,
                static (syntaxContext, cancellationToken) => syntaxContext);
            initializationContext.RegisterSourceOutput(source, emitter);
        }
        RegisterAttributeAndEmitAction(FullyQualifiedObfuscatedStringAttributeClassName, EmitCodeForObfuscatedString);
        RegisterAttributeAndEmitAction(FullyQualifiedObfuscatedBytesAttributeClassName, EmitCodeForObfuscatedBytes);
    }

    private static void EmitCodeForObfuscatedString(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        EmitCodeCore(
            context,
            source,
            FullyQualifiedObfuscatedStringAttributeClassName,
            ImmutableArray.Create(ObfuscationType.String, ObfuscationType.IMemoryOwnerChar),
            DiagnosticDescriptors.InvalidReturnTypeForObfuscatedString);
    }
    private static void EmitCodeForObfuscatedBytes(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        EmitCodeCore(
            context,
            source,
            FullyQualifiedObfuscatedBytesAttributeClassName,
            ImmutableArray.Create(ObfuscationType.ByteArray, ObfuscationType.IMemoryOwnerByte),
            DiagnosticDescriptors.InvalidReturnTypeForObfuscatedBytes);
    }

    private static void EmitCodeCore(SourceProductionContext context, GeneratorAttributeSyntaxContext source, string fullyQualifiedAttributeName, ImmutableArray<ObfuscationType> validReturnTypes, DiagnosticDescriptor diagnosticDescriptorWhenInvalidReturnType)
    {
        var methodSymbol = (IMethodSymbol)source.TargetSymbol;
        var methodDeclarationSyntax = (MethodDeclarationSyntax)source.TargetNode;

        var obfuscationType = GetObfuscationTypeWithDiagnostics(
            context,
            methodSymbol,
            methodDeclarationSyntax,
            source.SemanticModel,
            validReturnTypes,
            diagnosticDescriptorWhenInvalidReturnType);
        if (obfuscationType == ObfuscationType.None)
        {
            return;
        }

        var containingClassSymbol = methodSymbol.ContainingType;
        if (containingClassSymbol == null)
        {
            return; // when the method is not contained with in type. I'm not sure this will happen when using C# language.
        }

        // If I use "Span<byte> key = stackalloc byte[16];" then
        // I get a error "The target process exited with code -2146233082 (0x80131506) while evaluating the function '<LAST_USED_METHOD>'."
        // I don't know why, but I can avoid that by using MemoryPool.
        string decryptionCode;
        if (fullyQualifiedAttributeName == FullyQualifiedObfuscatedStringAttributeClassName)
        {
            var attributeArgument = GetAttributeConstructorArgument(methodSymbol, fullyQualifiedAttributeName);
            string str = (string)attributeArgument.TypedConstant.Value!;
            decryptionCode = XorObfuscator.GenerateCodeForDeobfuscateString(str.AsSpan(), attributeArgument.KeySize, attributeArgument.ClearBufferWhenDisposing, obfuscationType == ObfuscationType.String);
        }
        else if (fullyQualifiedAttributeName == FullyQualifiedObfuscatedBytesAttributeClassName)
        {
            var attributeArgument = GetAttributeConstructorArgument(methodSymbol, fullyQualifiedAttributeName);
            byte[] bytes = attributeArgument.TypedConstant.Values.Select(x => (byte)x.Value!).ToArray();
            decryptionCode = XorObfuscator.GenerateCodeForDeobfuscateBytes(bytes, attributeArgument.KeySize, attributeArgument.ClearBufferWhenDisposing, obfuscationType == ObfuscationType.ByteArray);
        }
        else
        {
            throw new InvalidOperationException($"Unknown fullyQualifiedAttributeName: {fullyQualifiedAttributeName}");
        }

        string code = $$"""
            // <auto-generated/>
            {{(methodSymbol.ContainingNamespace.IsGlobalNamespace ? string.Empty : $"{Environment.NewLine}namespace {methodSymbol.ContainingNamespace};")}}
            partial class {{methodSymbol.ContainingType.Name}}
            {
                {{SyntaxFacts.GetText(methodSymbol.DeclaredAccessibility)}}{{(methodSymbol.IsStatic ? " static" : string.Empty)}} partial {{methodSymbol.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}} {{methodSymbol.Name}}()
                {
            {{decryptionCode}}
                }
            }

            """;

        string generatingSourceFileName = Utils.SanitizeForFileName($"{(containingClassSymbol == null ? "__global__" : containingClassSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))}.{methodSymbol.Name}.{methodSymbol.ReturnType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}.CompileTimeObfuscator.g.cs");

        context.AddSource(generatingSourceFileName, code);
    }

    /// <summary>Returns value if there is no syntax error. Returns <see cref="ObfuscationType.None"/> and report diagnostic otherwise.</summary>
    private static ObfuscationType GetObfuscationTypeWithDiagnostics(
        SourceProductionContext context,
        IMethodSymbol methodSymbol,
        MethodDeclarationSyntax methodDeclarationSyntax,
        SemanticModel semanticModel,
        ImmutableArray<ObfuscationType> validReturnTypes,
        DiagnosticDescriptor diagnosticDescriptorWhenInvalidReturnType)
    {
        INamedTypeSymbol GetTypeSymbolFromName(string fullyQualifiedmetadataName) =>
            semanticModel.Compilation.GetTypeByMetadataName(fullyQualifiedmetadataName) ??
            throw new InvalidOperationException($"{fullyQualifiedmetadataName} is not found");

        var typeIMemoryOwnderOpened = GetTypeSymbolFromName("System.Buffers.IMemoryOwner`1");
        var typeByte = GetTypeSymbolFromName("System.Byte");
        var typeChar = GetTypeSymbolFromName("System.Char");
        var typeString = GetTypeSymbolFromName("System.String");
        var typeIMemoryOwnderByte = typeIMemoryOwnderOpened.Construct(typeByte);
        var typeIMemoryOwnderChar = typeIMemoryOwnderOpened.Construct(typeChar);
        var typeByteArray = semanticModel.Compilation.CreateArrayTypeSymbol(typeByte);

        bool HasReturnType(ISymbol symbol) => SymbolEqualityComparer.Default.Equals(methodSymbol.ReturnType, symbol);

        var obfuscationType = HasReturnType(typeString) ? ObfuscationType.String :
            HasReturnType(typeIMemoryOwnderChar) ? ObfuscationType.IMemoryOwnerChar :
            HasReturnType(typeByteArray) ? ObfuscationType.ByteArray :
            HasReturnType(typeIMemoryOwnderByte) ? ObfuscationType.IMemoryOwnerByte :
            ObfuscationType.None;

        if (!validReturnTypes.Contains(obfuscationType))
        {
            context.ReportDiagnostic(Diagnostic.Create(diagnosticDescriptorWhenInvalidReturnType, methodDeclarationSyntax.Identifier.GetLocation()));
            return ObfuscationType.None;
        }

        if (methodSymbol.Parameters.Length > 0)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MethodMustNotHaveParameters, methodDeclarationSyntax.Identifier.GetLocation()));
            return ObfuscationType.None;
        }

        if (methodSymbol.Arity > 0)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MethodMustNotHaveTypeParameters, methodDeclarationSyntax.Identifier.GetLocation()));
            return ObfuscationType.None;
        }

        if (!methodSymbol.IsPartialDefinition)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MethodMustBePartial, methodDeclarationSyntax.Identifier.GetLocation()));
            return ObfuscationType.None;
        }

        return obfuscationType;
    }

    private record struct AttributeConstructorArgument(TypedConstant TypedConstant, int KeySize, bool ClearBufferWhenDisposing);

    private static AttributeConstructorArgument GetAttributeConstructorArgument(IMethodSymbol methodSymbol, string fullyQualifiedAttributeName)
    {
        var attributeData = methodSymbol.GetAttributes().Single(
            x => x.AttributeClass?.ToDisplayString() == fullyQualifiedAttributeName);

        if (attributeData.ConstructorArguments.Length != 3)
        {
            throw new InvalidOperationException($"ConstructorArguments.Length is {attributeData.ConstructorArguments.Length}");
        }

        return new AttributeConstructorArgument(
            attributeData.ConstructorArguments[0],
            (int)attributeData.ConstructorArguments[1].Value!,
            (bool)attributeData.ConstructorArguments[2].Value!);
    }
}

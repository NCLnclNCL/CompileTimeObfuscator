using System;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Diagnostics;

namespace CompileTimeObfuscator.Tests.TestUtils;
public static class CSharpGeneratorRunner
{
    private static Compilation s_baseCompilation = default!;

    [ModuleInitializer]
    public static void InitializeCompilation()
    {
        string baseAssemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location)!;
        var references = Directory.GetFiles(baseAssemblyPath)
            .Where(path =>
            {
                string fileName = Path.GetFileName(path);
                bool seemsLikeStandardDll = fileName.StartsWith("System") || fileName is "mscorlib.dll" or "netstandard.dll";
                bool endsWithNativeDll = fileName.EndsWith("Native.dll");
                return seemsLikeStandardDll && !endsWithNativeDll;
            })
            .Select(path => MetadataReference.CreateFromFile(path))
            .ToArray();

        var compilation = CSharpCompilation.Create(
            "GeneratorTest",
            references: references,
            options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        s_baseCompilation = compilation;
    }

    public readonly record struct GeneratorResult(
        string? GeneratedSource,
        ImmutableArray<Diagnostic> DiagnosticsReportedByGenerator,
        Compilation Compilation);

    public static GeneratorResult RunGenerator(
        string source,
        string[]? preprocessorSymbols = null,
        AnalyzerConfigOptionsProvider? options = null,
        bool verifyIfDiagnosticsReportedByGeneratorIsEmpty = false)
    {
        preprocessorSymbols ??= new[] { "NET6_0_OR_GREATER" };
        var parseOptions = new CSharpParseOptions(LanguageVersion.CSharp11, preprocessorSymbols: preprocessorSymbols);
        var driver = CSharpGeneratorDriver.Create(new CompileTimeObfuscatorGenerator())
            .WithUpdatedParseOptions(parseOptions);
        if (options != null)
        {
            driver = (CSharpGeneratorDriver)driver.WithUpdatedAnalyzerConfigOptions(options);
        }

        var compilation = s_baseCompilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source, parseOptions));
        driver.RunGeneratorsAndUpdateCompilation(compilation, out var newCompilation, out var diagnosticsReportedByGenerator);

        var diagnosticsAfterAddedGeneratedSource = newCompilation.GetDiagnostics();
        if (diagnosticsAfterAddedGeneratedSource.Any(diagnostic =>
            {
                bool isError = diagnostic.Severity == DiagnosticSeverity.Error;
                bool isReportedByGenerator = diagnostic.Id.StartsWith("CTO");
                bool isPartialMethodError = diagnostic.Id == "CS8795"; // Partial method 'C.M()' must have an implementation part because it has accessibility modifiers
                return isError && !isReportedByGenerator && !isPartialMethodError;
            }))
        {
            throw CreateExceptionIndicatingFailedToCompile(source, diagnosticsAfterAddedGeneratedSource);
        }

        if (verifyIfDiagnosticsReportedByGeneratorIsEmpty && diagnosticsReportedByGenerator.Length > 0)
        {
            throw CreateExceptionIndicatingFailedToCompile(source, diagnosticsReportedByGenerator);
        }

        string? generatedSource = newCompilation.SyntaxTrees
            .SingleOrDefault(tree =>
            {
                string source = tree.ToString();
                return source.StartsWith("// <auto-generated/>") &&
                    !source.Contains($"internal sealed class {CompileTimeObfuscatorGenerator.ClassNameClearableBuffer}<T> : IMemoryOwner<T>");
            })
            ?.ToString();
        return new GeneratorResult(generatedSource, diagnosticsReportedByGenerator, newCompilation);
    }

    private static Exception CreateExceptionIndicatingFailedToCompile(string source, ImmutableArray<Diagnostic> diagnostics)
    {
        string errors = string.Join(Environment.NewLine, diagnostics);
        string message = $"""
            The specified source can not be compile.
            Source:
            {source}

            Errors:
            {errors}
            """;
        return new ArgumentException(message, nameof(source));
    }
}
